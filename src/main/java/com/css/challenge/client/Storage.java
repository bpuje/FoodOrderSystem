package com.css.challenge.client;import java.util.*;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;public class Storage {    private final int coolerCapacity = 8;    private final int heaterCapacity = 8;    private final int shelfCapacity = 15;    private final Queue<Order> cooler = new LinkedList<>();    private final Queue<Order> heater = new LinkedList<>();    private final PriorityQueue<Order> shelf = new PriorityQueue<>(Comparator.comparingInt(Order::getFreshness));    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);    public Storage () {        scheduler.scheduleAtFixedRate(this::processOrders, 0, 1, TimeUnit.SECONDS);    }    public synchronized void placeOrder(Order order) {        if (order.getTemp().equals("cold") && cooler.size() < coolerCapacity) {            cooler.add(order);            System.out.println("placed Cooler Order: " + cooler);        } else if (order.getTemp().equals("hot") && heater.size() < heaterCapacity) {            heater.add(order);            System.out.println("placed Heater Order: " + heater);        } else {            if (shelf.size() >= shelfCapacity) {                discardLeastFresh();            }            shelf.add(order);        }    }    private void discardLeastFresh() {        if (!shelf.isEmpty()) {            Order discarded = shelf.poll(); // removing order with lowest freshness            System.out.println("Discarded Order: " + discarded);        }    }    public synchronized void processOrders() {        List<Order> toMove = new ArrayList<>();        // Move orders to proper storage        for (Order order : shelf) {            if (order.getTemp().equals("cold") && cooler.size() < coolerCapacity) {                toMove.add(order);                cooler.add(order);            } else if (order.getTemp().equals("hot") && heater.size() < heaterCapacity) {                toMove.add(order);                heater.add(order);            }        }        shelf.removeAll(toMove);        // Remove expired orders        removeExpiredOrders();    }    public void removeExpiredOrders() {        Iterator<Order> iterator = shelf.iterator();        while (iterator.hasNext()) {            Order order = iterator.next();            if (order.getFreshness() <= 0) {                iterator.remove();                System.out.println("Expired Order Removed: " + order);            }        }    }//    public synchronized void moveOrders() {//        List<Order> movedOrder = new ArrayList<>();//        Iterator<Order> iterator = shelf.iterator();////        while (iterator.hasNext()) {//            Order order = iterator.next();////            if (order.getTemp().equals("cold") && cooler.size() < coolerCapacity) {//                movedOrder.add(order);//                cooler.add(order);//                System.out.println("moved to Cooler: " + cooler);//            } else if (order.getTemp().equals("hot") && heater.size() < heaterCapacity) {//                movedOrder.add(order);//                heater.add(order);//                System.out.println("moved to Heater: " + heater);//            }//        }//        shelf.removeAll(movedOrder);//    }////    public synchronized void removeExpiredOrders() {//        cooler.removeIf(order -> order.getFreshness() <= 0);//        heater.removeIf(order -> order.getFreshness() <= 0);//        shelf.removeIf(order -> order.getFreshness() <= 0);//    }    public synchronized int coolerSize() {        return cooler.size();    }    public synchronized  int heaterSize() {        return heater.size();    }    public synchronized int shelfSize() {        return shelf.size();    }}